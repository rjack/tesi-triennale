\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{verbatim}

\pagestyle{fancy}

\oddsidemargin=30pt
\evensidemargin=20pt

% Sillabazione
\hyphenation{}

% Intestazione e piè di pagina
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}

% Interlinea
\linespread{1.3}

\begin{document}

%
% Dedica
%
\begin{titlepage}
  % No numero di pagina
  \thispagestyle{empty}
  \topmargin=6.5cm
  \raggedleft
  \large
  \em A Chiara
  \newpage
  % Non numera l'ultima pagina a sinistra.
  \clearpage{\pagestyle{empty}\cleardoublepage}
\end{titlepage}


\pagenumbering{roman}

\chapter*{Introduzione}
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}
\addcontentsline{toc}{chapter}{Introduzione}

TODO

% Non numera l'ultima pagina a sinistra.
\clearpage{\pagestyle{empty}\cleardoublepage}

% Indice
\tableofcontents
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
% Non numera l'ultima pagina a sinistra.
\clearpage{\pagestyle{empty}\cleardoublepage}

\chapter{Definizione del problema}

Def problema: in un ambiente con numerose reti senza fili eterogenee
per tecnologia, politica di accesso e proprietà, si vuole dare a un
dispositivo di rete mobile la possibilità di attraversare i campi
d'azione delle suddette reti utilizzando quella che in ogni momento
risulti offrire l'accesso migliore ai servizi. Tale dispositivo mobile
viene chiamato Mobile Node (MN) e si suppone sia dotato di più d'una
interfaccia di rete senza fili. Dette interfacce di rete (NIC) si
potranno associare a diverse reti e dovranno essere monitorate con
continuità per determinare in ogni momento quale di queste sia la più
adatta ad effettuare l'invio dei dati. La scelta di questa interfaccia
designata si potrà basare su numerosi criteri di scelta tra cui la
qualità del segnale radio, la percentuale di pacchetti persi, la
larghezza di banda offerta dal canale, la latenza di comunicazione,
esigenze di sicurezza, eventuale costi economici legati all'accesso
alla rete e possibili preferenze specificate direttamente
dall'utente. L'insieme dei criteri di scelta definisce le politiche di
QoS in uso, ovvero l'insieme di regole e vincoli che devono essere
rispettati per garantire all'utente del MN un'esperienza soddisfacente
di utilizzo dei servizi. Le soluzioni dovranno fornire sia i
meccanismi per permettere all'utente, o alle applicazioni da lui
utilizzate, di specificare quali siano dette politiche, sia meccanismi
che le implementino.

TODO: immagine che mostri un MN che attraversa più reti e che mostra i
punti di handover.


\chapter{Panoramica delle soluzioni}1
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}
L'obiettivo è di permettere a un MN di muoversi attraverso reti
wireless di natura eterogenea in maniera trasparente, ovvero senza
interrompere eventuali connessioni attive durante la transizione da
una rete all'altra. Perché questo sia possibile è necessario che ogni
MN sia a) univocamente identificato e b) universalmente raggiungibile
dagli altri nodi, in qualunque rete si trovi. Inoltre ogni MN dovrebbe
c) monitorare la qualità di ogni connessione wireless per poter
individuare la rete che offre le migliori garanzie di servizio e d)
eseguire un cambio di associazione trasparente per assicurare una
transizione senza interruzioni da una rete all'altra.

Le architetture proposte non hanno una collocazione ben precisa
all'interno dello stack di protocolli ISO/OSI.

Questo capitolo presenterà brevemente le soluzioni più importanti
presenti in letteratura, senza entrare nel merito dei singoli dettagli
tecnici, ma raggruppando e catalogando per tipo i vari approcci e
mostrando come ogni soluzione affronti ognuno dei quattro punti
chiave.

\section{Soluzioni \emph{single layer}}
Le architetture seguenti sono dette \emph{single layer} perché hanno
una collocazione ben precisa nello stack ISO/OSI e operano soltanto al
loro livello. L'analisi di queste soluzioni mostrerà i limiti
dell'approccio single layer, limiti che saranno superati dagli
approcci \emph{cross layer} descritti nella sezione successiva.

Queste architetture coprono i principali strati dello stack ISO/OSI:
Mobile IPv6 \cite{bib:mipv6} e la sua estensione Multiple Care-of
Addresses Registration \cite{bib:mcoa} agiscono a livello
\emph{network}, Host Identity Protocol \cite{bib:hip} definisce un
livello aggiuntivo tra \emph{network} e \emph{transport}, Datagram
Congestion Control Protocol \cite{bib:dccp} e Mobile Stream Control
Transport Protocol \cite{bib:m-sctp} lavorano a livello
\emph{transport}, infine Terminal Mobility Support Protocol
\cite{bib:tmsp} e MMUSE \cite{bib:mmuse} agiscono a livello
\emph{session}.

\subsection{Mobile IPv6 e Multiple Care-of Addresses Registration}
* Home Agent nella rete fa da LR\\
* Host parlano IPv6\\
* quindi infrastrutture di rete attuali non sono adatte\\
* no multi homing, perche' il protocollo non lo permette\\
* handover tribolato\\
MCoA\\
* estensione di MIPv6\\
* permette a MN di registrare più IP address con il suo Home Agent\\
* FlowMob permette di separare flussi di traffico tra le varie NIC\\
* stessi problemi di MIPv6: tutte le infrastrutture da cambiare.

\subsection{Host Identity Protocol}
* server tipo DNS opera fuori dalla rete di accesso\\
* mappa identificatori a posizioni\\
* il layer aggiuntivo deve essere installato sia nel MN che nel
  CN.\\
* Poco pratico! Non è detto che il CN si prenda la briga di installare\\
  il layer aggiuntivo.\\

\subsection{Datagram Congestion Control Protocol}
* ogni MN annuncia il cambiamento di rete all'altro nodo\\
* funziona solo se cambiano rete uno alla volta! Due MN che cambiano
  rete simultaneamente sono irragiungibili.\\
* richiedono modifica delle applicazioni.\\

\subsection{Mobile Stream Control Transport Protocol}
Idem a DCCP.

\subsection{Terminal Mobility Support Protocol}
* SIP user agent pubblico fuori dalle reti di accesso, mappa
  user@foo.com a posizione\\
* handover lento! ogni riconfigurazione interrompe la comunicazione
  finchè MN non ha finito di comunicare con l'user agent pubblico.

\subsection{MMUSE}
* server SIP, Session Border Controller (SBC) all'interno del
  sistema autonomo, che può essere composto da più reti wireless
  eterogenee.\\
* permette di attraversare i firewall e di spostarsi da una subnet
  all'altra all'interno dello stesso AS.\\
* MN non si può muovere tra reti di diversi AS.\\

\subsection{Considerazioni}
Tutte soluzioni tranne MMUSE hanno problemi con NAT e
firewall. Bisogna usare TURN e STUN. Tutte soluzioni senza
multi-homing, tranne MCoA.


\section{Soluzioni \emph{cross layer}}
Le architetture presenti sono dette \emph{cross layer} perché agiscono
a multipli livelli dello stack ISO/OSI, superando i limiti delle
architetture \emph{single layer} descritte in precedenza.

Il concetto di fondo di queste architetture è utilizzare le
informazioni disponibili al livello \emph{network} per poter prendere
decisioni efficaci di qualità di servizio ai livelli più alti.

Questa sezione confronterà le soluzioni ``Media Optimization Network
Architecture'' (MONA) e ``Always Best Packet Switching'' (ABPS).

Entrambe le architetture agiscono in uno scenario in cui ci sono
numerosi Mobile Node (MN), ognuno dotato di più interaccie di rete
(NIC), che operano in un ambiente dove sono disponibili più reti
wireless, eterogenee per tecnologia e dominio. Si immagina che i
movimenti degli utenti portino i vari MN ad attraversare le aree di
copertura delle reti wireless, per cui un MN connesso ad una
determinata rete A potrebbe spostarsi in un'area in cui giungono sia i
segnali della rete A che quelli di una seconda rete B, per poi
spostarsi ulteriormente nell'area di copertura della sola rete
B. Durante questi spostamenti l'utente deve essere in grado di
utilizzare applicazioni di rete real time, come Voice over IP e Video
on Demand, senza avere ripercussioni sulla qualità dell'esperienza. Il
traffico real time deve inoltre coesistere con il traffico non real
time delle applicazioni TCP/IP tradizionali, senza per questo venirne
penalizzato.

\subsection{Media Optimization Network Architecture}
%% Breve panoramica di MONA

MONA definisce uno strato aggiuntivo, posizionato tra gli strati
\emph{network} e \emph{transport} e denominato \emph{association
  layer}, che implementa l'Association Management Protocol (AMP);
detto protocollo risiete degli host e ne gestisce i singoli
collegamenti di rete, nascondendone la molteplicità allo strato
\emph{transport} superiore.

La molteplicità di collegamenti viene sfruttata per gestire il
problema dell'\emph{handover}, ovvero del passaggio dall'associazione
con una rete all'associazione con un'altra. In MONA ogni NIC tenta di
associarsi al proprio access point, e AMP decide se utilizzare una
sola NIC, quando il collegamento è soddisfacente, o se utilizzarne più
d'una contemporaneamente, quando il monitoraggio della NIC mostra
problemi di degrado delle prestazioni di rete.

MONA inoltre propone una modifica al comportamento degli access point
per supportare più efficientemente il traffico bidirezionale tipico
delle applicazioni VoIP e una aggiunta alle frame di \emph{probe} e
\emph{beacon} per permettere ai MN di selezionare l'access point con
migliore \emph{throughput}.


\subsection{Always Best Packet Switching}
%% Breve panoramica di ABPS

Fixed server, rappresenta MN. Uso simultaneo di tutte le
NIC. Scorciatoie SIP per evitare dialoghi lenti con server
SIP. Sicurezza e identificazione: pre-shared key, flow-id e niente
REINVITE. Meccanismi a disposizione per diverse politiche: VoIP usa
error detection ed early retransmission, VoD usa più NIC
contemporaneamente per maggior banda: virtual channels per selezionare
politiche. Estensioni: ABPS-SIP e ABPS-RTP.


\subsection{Considerazioni}
Vantaggi delle due soluzioni rispetto a quelle single layer.

\clearpage{\pagestyle{empty}\cleardoublepage}


\chapter{Media Optimization Network Architecture}
Questo capitolo analizzerà nel dettaglio l'architettura MONA.

\clearpage{\pagestyle{empty}\cleardoublepage}


\chapter{Always Best Packet Switching}
TODO: breve presentazione. Esempio: Always Best Packet Switching
(d'ora in avanti ABPS) è frutto di una ricerca in corso all'Università
di Bologna, etc. etc.

TODO: obiettivo in breve.

La selezione dell'interfaccia dipende dalle preferenze dell'utente,
dalle necessità intrinseche all'applicazione, dalle caratteristiche
fisiche ed economiche del collegamento e dalle caratteristiche del
pacchetto da spedire.

L'architettura si rivolge ai servizi multimediali interattivi basati
sui protocolli SIP e RTP, con l'obiettivo di permetterne l'utilizzo in
un contesto di mobilità urbana attraverso reti eterogenee per
tecnologia, amministrazione e costo, in presenza di NAT e firewall,
garantendo QoE e sicurezza.

\section{Session Initiation Protocol}

ABPS utilizza il protocollo SIP e ne definisce un'estensione,
denominata ABPS-SIP. Per illustrare ABPS è quindi necessario trattare
il protocollo SIP nei punti salienti che riguardano l'architettura in
esame.

Questa sezione presenta quindi una panoramica del protocollo SIP,
mostrando i ruoli degli host, la gestione della sessione e alcuni
limiti dovuti alla presenza di firewall e NAT. Successivamente verrà
mostrato come ABPS estende il protocollo SIP per superare questi
limiti.

\subsection{Panoramica}

Il protocollo SIP è utilizzato per creare il contesto di una
comunicazione tra due o più entità di rete.

Per mezzo di SIP due host possono venire in contatto e accordarsi sui
parametri della sessione di comunicazione, dopo di che il
trasferimento dati avviene in modo diretto, secondo le modalità
concordate.

\subsection{Agenti SIP}

Tra i vari ruoli che SIP prevede per gli host in gioco, la trattazione
di ABPS richiede di illustrare gli User Agent Client (UAC), gli User
Agent Server (UAS) e i Back-to-back User Agent (B2BUA).

\paragraph{User Agent Client.}
È definito come un'entità logica che crea nuove richieste SIP e le
invia sulla rete all'User Agent Server. Per esempio, un softphone che
inizi una chiamata VoIP prende il ruolo di UAC, perché genera e
spedisce la richiesta di invito.

\paragraph{User Agent Server.}
È definito come un'entità logica che crea le risposte alla richieste
ricevute. Un esempio di UAS è il server che risponde alle richieste di
registrazione (Registrar).

\paragraph{Back-to-back User Agent.}

È definito come un'entità logica che riceve le richieste da un UAC e
si comporta come se fosse un UAS, ma invece di rispondere
direttamente, inoltra la richiesta a un UAS effettivo, comportandosi
da UAC. In altre parole, un B2BUA è un intermediario tra UAC e UAS:
UAC crede che il B2BUA sia l'UAS, dall'altra parte l'UAS crede che il
B2BUA sia l'UAC.

\subsection{Gestione delle sessioni SIP}

In uno scenario VoIP, l'applicazione UAC utilizza il protocollo SIP
per inviare all'UAS un messaggio REGISTER, che segnala che l'utente è
collegato e pronto a ricevere e inviare chiamate. Dopo che l'UAC si è
registrato al servizio, può instaurare una sessione mediante un
messaggio INVITE, che specifica l'identificativo dell'utente da
contattare e i dati dell'utente chiamante; ricevuta la richiesta
INVITE, il server recupera l'indirizzo IP dell'utente specificato e
instaura una sessione tra i due partecipanti, che possono comunicare
direttamente mediante protocollo RTP.

Nel caso in cui il chiamante modifichi il proprio stato durante una
conversazione, l'applicazione invia un nuovo messaggio INVITE
contentente i parametri aggiornati, per permettere al server di
reinstaurare la sessione con le nuove caratteristiche.

Il meccanismo di re-INVITE è intrinsecamente lento: il mittente deve
contattare il server, il server deve a sua volta contattare il
destinatario e solo a quel punto la comunicazione tra mittente e
destinatario può continuare nella nuova sessione. Nonostante questo
procedimento possa avvenire in automatico, ovvero senza intervento
manuale dell'utente, la comunicazione vocale deve essere interrotta
finché non viene instaurata la nuova sessione, condizionando
l'esperienza utente.

ABPS definisce delle scorciatoie di segnalazione per rendere diretto il
procedimento di re-INVITE; i partecipanti possono modificare i
parametri della sessione in cui sono coinvolti senza dover
interpellare il server e quindi evitando di dover attendere che la
sessione sia reinstaurata.

\subsection{Problematiche dovute a Firewall e NAT}

Il protocollo SIP si limita a creare il contesto della comunicazione,
permettendo ai partecipanti di specificare le caratteristiche della
sessione, instaurata la quale lo scambio di dati avviene in maniera
diretta tra i due host. Alla luce di ciò, NAT e firewall sono
impedimenti perché non permettono a un host di essere direttamente
raggiungibile dalla controparte. Firewall e NAT sono spesso di
proprietà dell'organizzazione che offre connettività, soprattutto in
un contesto WAN, per cui l'utente non ha possibilità di impostare
soluzioni di port-forwarding. Il metodo più comune prevede che
l'utente imposti l'applicazione con l'indirizzo di un server STUN o
TURN in modo da utilizzare uno di questi servizi. Purtroppo STUN
richiede un certo tempo per funzionare, mentre TURN è un vero e
proprio collo di bottiglia, quindi entrambi i metodi non sono
compatibili con la necessità di effettuare handover in tempi
estremamente brevi.

ABPS impiega un B2BUA modificato, raggiungibile pubblicamente su
Internet, che nasconde l'indirizzo IP del MN. Grazie a questo B2BUA, i
MN possono essere rappresentati da un host pubblicamente raggiungibile
su Internet, quindi evitando in maniera semplice e sicura i problemi
di NAT e firewall.

\section {Obiettivi di ABPS}

Gli obiettivi di ABPS sono:

\begin{itemize}
\item identificare ogni MN in modo univoco in ogni momento, a
  prescindere dalle reti a cui è connesso,
\item permettere a un MN di essere raggiungibile da qualsiasi altro
  host e in particolare da altri MN,
\item monitorare la qualità di servizio di ogni canale di un MN per
  predire la necessità di un handover,
\item effettuare detto handover in maniera trasparente, senza che la
  QoE ne risenta.
\end{itemize}

Inoltre, perché la soluzione sia applicabile nella pratica, è
necessario che ABPS non richieda modifiche né agli apparecchi harware,
né alle attuali applicazioni.

\section {Architettura proposta}
L'architettura ABPS propone tre linee guida per affrontare le
problematiche descritte precedentemente.

\subsection{Rappresentanza pubblica per MN}
In un contesto di estrema mobilità, l'identificazione e la
raggiungibilità del MN sono problematiche perché ad ogni handover il
MN utilizza un indirizzo IP diverso da quello che utilizzava fino a
quel momento. In ABPS il problema è escerbato dal fatto che il MN può
decidere di inviare due pacchetti consecutivi appartenenti allo stesso
flusso attraverso due interfacce diverse. In questo caso il ricevente
non avrebbe modo di riconoscere il mittente, perché non avrebbe modo
di ricondurre a un solo mittente i vari indirizzi sorgente presenti
nel pacchetti ricevuti.

ABPS definisce un servizio, chiamato ABPS--Server, che nasconde la
mobilità del MN agli altri host. ABPS--Server è un servizio di
indirizzo noto, raggiungibile da Internet e indipendente da una
singola rete di accesso.

\subsection{Uso simultaneo di tutte le interfacce dei MN}
La caratteristica chiave di ABPS è la capacità di instradare ogni
pacchetto su interfacce potenzialmente differenti, includendo nella
scelta le caratteristiche del pacchetto stesso. Le altre soluzioni di
handover invece effettuano la scelta a un livello più alto,
selezionando l'interfaccia di rete su cui instradare la sessione di
comunicazione e mantenendo la scelta fino a che il collegamento viene
giudicato soddisfacente.

Effettuare a scelta a livello di pacchetto permette ad ABPS--client di
collaborare con ABPS--server per implementare le politiche di
bilanciamento di traffico e di recupero d'errore al più fine dei
livelli di granularità possibili.

\subsection{Segnalazioni rapide tra partecipanti a una sessione}
L'handover, ovvero la commutazione del collegamento in uso da
un'interfaccia a un'altra, è un momento estremamente delicato e deve
essere eseguito in modo trasparente per garantire un'esperienza utente
soddisfacente. Nelle architetture che selezionano un collegamento e lo
usano in maniera esclusiva, l'handover è un avvenimento relativamente
raro perché una volta che il client sceglie un'interfaccia per l'invio
dei dati, la scelta persiste finché la qualità del collegamento resta
soddisfacente. L'interfaccia scelta può restare tale per un periodo di
tempo che varia dall'ordine dei giorni all'ordine dei minuti,
dipendentemente dal grado di mobilità dell'utente. In ABPS invece le
interfacce sono continuamente connesse e la scelta viene effettuata
pacchetto per pacchetto; questo significa che la frequenza
dell'handover si riduce all'ordine dei millisecondi. Con tempi di
handover così ristretti, ogni soluzione di gestione mediante
segnalazioni end-to-end non è utilizzabile. In particolare la
procedura SIP prevede un meccanismo di re-INVITE che


\clearpage{\pagestyle{empty}\cleardoublepage}


\chapter{Considerazioni finali}
Riprende superiorità di cross layer su single layer e confronta punti
forti e deboli di MONA e ABPS.

Propone scenari di test?

\clearpage{\pagestyle{empty}\cleardoublepage}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                   DA QUI IN POI E' ROBA VECCHIA                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{comment}

% Capitoli
\chapter{Scenario}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}

Lo scenario da considerare è illustrato in figura \ref{fig:scenario} e
originariamente presentato negli articoli \emph{Robust Wireless Medium
  Access for VoWLAN Applications: A Cross--Layer QoS Mechanism}
\cite{bib:rwma} e \emph{Always Best Packet Switching: the mobile VoIP
  case study} \cite{bib:abps}. Si assuma che esista una comunicazione
vocale tra due sistemi A e B, in figura rappresentati come ``Alice'' e
``Bob''. Il sistema A è un dispositivo mobile dotato di più di
un'interfaccia wireless, ognuna delle quali è associata con un diverso
access point. I vari access point possono appartenere a infrastrutture
di rete e domini differenti e quindi essere completamente indipendenti
l'uno dall'altro. Gli access point sono connessi a Internet attraverso
una connessione via cavo. Il sistema B è un dispositivo fisso,
connesso a Internet via cavo attraverso una comune allacciamento
Internet a banda larga, come ADSL o fibra ottica.
\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{img/scenario}
\caption{Scenario}
\label{fig:scenario}
\end{figure}
La comunicazione VoIP tra i sistemi A e B si affida quindi a due tipi
di connessione: quella wireless, tra A e gli access point, e quella
via cavo tra gli access point e B.

\section{Vincoli qualitativi}
Come mostrato, il percorso dei dati da un sistema VoIP all'altro deve
attraversare segmenti camblati e altri senza fili; di questi gli
ultimi sono i più problematici, perché soffrono di tre gravi
inconvenienti: alta latenza, frequenti errori di trasmissione e
interruzione e ripristino della connessione nel cambiare access
point. Latenza ed errori frequenti possono degradare la qualità di una
comunicazione VoIP via wireless fino a renderla inintelleggibile,
mentre l'interruzione della connessione durante il passaggio da un
access point a un altro impedisce la mobilità del sistema obbligando
l'utente a restare nei pressi del ripetitore wireless in uso, pena la
disconnessione e l'interruzione della comunicazione.

Per garantire una buona qualità del servizio, il sistema RWMA deve
operare soddisfando vincoli di interattività, affidabilità e mobilità.

\subsection{Interattività}
L'interattività di una conversazione VoIP è influenzata dalla latenza
dei pacchetti che ne compongono il flusso di rete. La latenza di
trasmissione è definita come il tempo trascorso dall'istante del
campionamento della voce sul sistema di origine all'instante di
riproduzione audio della stessa voce sul sistema di destinazione. Le
raccomandazioni ITU--T \cite{bib:itu-t} indicano 150 ms come latenza
massima di una comunicazione VoIP soddisfacente; al di sopra di questa
soglia l'interattività della conversazione non è più accettabile.

\subsection{Affidabilità}
L'affidabilità di una conversazione VoIP dipende dalla capacità della
rete di portare a destinazione quanti più pacchetti possibili. Un
pacchetto è considerato perso quanto viene trasmesso dal sistema
origine e non viene ricevuto dal sistema destinazione. Per condurre
una conversazione comprensibile è necessario che la percentuale di
pacchetti persi resti al di sotto del 10\% \cite{bib:itu-t}. Poiché
per motivi di interattività le comunicazioni VoIP si svolgono su
protocollo UDP, la rete non offre nessun tipo di servizio di
trasmissione affidabile.

\subsection{Mobilità}
La mobilità dell'utente è fortemente limitata dallo scarso raggio
d'azione offerto dalle attuali apparecchiature WiFi. Le interfacce
WiFi sono in grado di interrompere l'associazione con l'access point
in uso per crearne una nuova con un secondo solo quando i suddetti
access point sono parte della stessa infrastruttura di rete. Questa
limitazione deriva direttamente dal funzionamento del protocollo IP:
cambiando rete di accesso l'interfaccia wireless riceve un nuovo
indirizzo IP e deve reinstaurare la connessione da zero. Ciò che si
vuole è invece un processo di disconnessione e riconnessione
trasparente all'applicazione, in modo che la chiamata VoIP non venga
interrotta, e rapido, in modo da non violare il requisito di
interattività precedentemente esposto.

\section{Il meccanismo RWMA}
Il meccanismo RWMA è costituito da più componenti, schematizzati in
figura \ref{fig:rwma}, che cooperano per risolvere i tre problemi di
interattività, affidabilità e mobilità. Questa sezione presenta
brevemente i componenti e illustra il loro ruolo nel progetto.
\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{img/rwma}
\caption{Schema del meccanismo RWMA}
\label{fig:rwma}
\end{figure}

\subsection{Transmission Error Detection (TED)}
Questo componente software è integrato nel kernel del sistema
operativo del dispositivo mobile e ha il compito di tenere sotto
costante osservazione l'esito dell'invio dei pacchetti sulle
interfaccie wireless. Ogni volta che un'interfaccia WiFi invia un
\emph{frame} 802.11, questa deve attendere che l'access point risponda
con un frame di \emph{acknowledgment} che confermi l'avvenuta
ricezione. Nel caso in cui questo frame non venga ricevuto entro un
certo periodo di tempo, l'interfaccia ritenta la trasmissione fino a
un certo limite di volte, raggiunto il quale il frame viene
scartato. Se l'interfaccia riceve l'ACK, il firmware notifica il
kernel dell'avvenuta ricezione; al contrario, se il numero massimo di
tentativi viene raggiunto senza che l'interfaccia abbia ricevuto un
ACK, il firmware notifica il kernel del fallimento. Compito del TED è
rilevare queste notifiche positive e negative inviate dal firmware
dell'interfaccia e metterle a disposizione di applicazioni in
\emph{user space}.

\subsection{UDP Load Balancer (ULB)}
Questo componente software è un'applicazione in \emph{user space}
eseguita sul dispositivo mobile e ha il compito di rilevare le
notifiche di TED, e in base a queste decidere se rispedire i datagram
che non sono stati ricevuti dall'access point; inoltre deve valutare
di volta in volta quale sia l'interfaccia WiFi migliore da impiegare
per l'invio dei datagram.

\subsection{Interface Monitor (IM)}
Questo componente software lavora a stretto contatto con il gestore
delle interfacce wireless del sistema mobile e notifica ULB
dell'attivazione e della disattivazione di ogni interfaccia; dalle
notifiche di IM, ULB è quindi in grado di conoscere in ogni momento
quali interfacce wireless siano attive e associate a un'access point e
tra queste scegliere la migliore da usare per l'inoltro dei datagram.

\subsection{Proxy Server (PS)}
Questo componente software ha il compito di nascondere la mobilità del
sistema A, in modo che questo possa essere continuamente raggiungibile
dal sistema B. Il sistema B è in comunicazione con PS ed è
quest'ultimo a occuparsi di tenere traccia dei cambiamenti di
indirizzo IP che occorrono quando il sistema A cambia rete WiFi o
riattiva un'interfaccia di rete; come ULB, anche PS deve decidere a
quale interfaccia inoltrare i datagram ricevuti da B, ma a differenza
di ULB non si occupa di ritrasmettere eventuali pacchetti persi.

\chapter{Simulazione}
% Obiettivi a cui punto. Spiegazione soluzioni, algoritmi e scelte
% effettuate.
Tra i componenti del sistema RWMA descritti nel capitolo precedente,
UDP Load Balancer e Proxy Server ospitano il meccanismo su cui si basa
la qualità del servizio. Tutti gli altri meccanismi si occupano di
rilevare e trasmettere notifiche di errori o successi durante l'invio
di un datagram, quindi il comportamento è molto ben definito. ULB e PS
invece hanno il compito molto generico di dover scegliere
l'interfaccia \emph{migliore} per l'invio di ogni datagram. Gli
algoritmi di ULB e PS devono pertanto scegliere una definizione
operativa di ``migliore'' e applicarla alle interfacce WiFi in
uso.

In prima approssimazione un'interfaccia WiFi si può definire migliore
di un'altra quando offre maggiori probabilità di soddisfare i vincoli
di interattività e affidabilità descritti nel precedente capitolo; in
altre parole quando le stime di latenza e percentuale di pacchetti
persi per una data interfaccia sono le più basse tra le stime delle
altre interfacce attive.

Esistono vari modi per condurre queste stime, difficili da valutare
senza condurre test e misurazioni sul campo. La simulazione vuole
essere un banco di prova sperimentale virtuale, in cui condurre test
in maniera più comoda ed economica che nel mondo reale.

Scopo della simulazione è quindi confrontare diversi algoritmi di
stima della qualità delle interfacce WiFi per i componenti UDP Load
Balancer e Proxy Server.

Le sezioni successive mostreranno i problemi incontrati e le soluzioni
proposte.

\section{UDP Load Balancer}
Questa sezione illustra i problemi che devono essere affrontati dagli
algoritmi implementati dal componente ULB.

\subsection{Ritrasmissione in tempi brevi}
ULB deve attendere le notifiche del TED e ritrasmettere i datagram che
sono stati segnalati come persi, ma senza superare i 150 ms di
ritardo. Dopo tale periodo di tempo, un datagram voce viene
considerato \emph{stale} (scaduto) e quindi scartato. Inoltre la
ritrasmissione di un datagram causa l'attesa di tutti gli altri
datagram in coda; se ULB impiega troppi tentativi per ritrasmettere un
datagram, quelli successivi hanno meno tempo a disposizione per uscire
dal sistema prima di scadere. Il rischio è di far scadere una serie di
pacchetti solo per aver impiegato troppo tempo nella ritrasmissione di
uno. In particolare, ogni datagram contiene circa 40 ms di voce,
quindi ULB riceve i datagram da inoltrare a intervalli di circa 40 ms;
ogni datagram ha quindi 40 ms in cui può impegnare l'interfaccia
designata senza rubare tempo agli altri datagram in coda. Se ULB
dedica molto più di 40 ms all'invio di un datagram, rischia di
compromettere l'intera coda.

La soluzione proposta è di permettere una sola ritrasmissione per
datagram e di assegnare una valutazione negativa all'interfaccia che
ha ricevuto la notifica d'errore d'invio dal componente TED. In questo
modo la ritrasmissione di un pacchetto non blocca lo smaltimento degli
altri pacchetti in coda e la valutazione negativa all'interfaccia
problematica permette all'altra interfaccia designata per l'invio.

\subsection{Valutazione interfacce -- ULB}
ULB deve stimare la qualità di ogni interfaccia WiFi osservando le
notifiche ricevuto da TED.

TODO: algoritmo valutazione interfaccia, lo scrivo per ultimo a scanso
fix dell'ultimo momento.

\subsection{Rilevazione delle capacità del firmware}
I firmware delle schede di rete wireless sono in grado di notificare
sia l'avvenuta trasmissione di un datagram (ACK), sia la mancata
trasmissione (NACK). Normalmente le schede WiFi in commercio sono in
grado di notificare entrambi i casi, ma alcuni firmware sono in grado
di notificare solo ACK, oppure solo NACK. Mancando un meccanismo nel
kernel Linux per conoscere con certezza le capacità di ogni firmware,
ULB deve dedurrne il tipo dalle notifiche ricevute da TED. Conoscere a
priori il tipo di notifiche che possono giungere da un'interfaccia è
importante perché in caso di firmware che non possa segnalare i
fallimenti, ULB deve supplire a questa mancanza impostando un timeout
di ritrasmissione.

\subsubsection{Il problema del firmware silenzioso}
Il tipo di firmware si deduce dal tipo di notifiche ricevute dallo
stesso ed è quindi un meccanismo banale. Esistono però due casi in cui
il firmware può rimanere ``silenzioso'' e quindi impossibile da
rilevare: quando una connessione pessima, cioè che perde tutti i
pacchetti, viene gestita da un firmware ACK che notifica solo
successi, oppure quando una connessione ottima, ovvero che non perde
nessun pacchetto, viene gestita da un firmware NACK che notifica solo
fallimenti.

Non esiste un comportamento predefinito che soddisfi entrambe le
situazioni: la strategia del ritrasmettere ogni datagram che non
riceva notifiche entro un certo timeout funziona solo nella prima
situazione e risulta completamente inadeguato nella seconda.

\subsection{Valutazione interfacce -- PS}
Poiché il sistema mobile è dotato di più interfacce, PS si trova
nella necessità di scegliere a quale di queste debba inoltrare i dati
ricevuti dal sistema fisso.

La soluzione proposta consiste nel rispondere all'interfaccia che ha
spedito gli ultimi dati ricevuti; in altre parole inviare i dati
all'ultimo indirizzo IP da cui PS ha ricevuto traffico.

Può però accadere che il sistema mobile non invii alcun dato perché
l'utente si limita ad ascoltare; in questo caso il PS non ha
cognizione di quale sia l'interfaccia a cui inviare i dati.

TODO: soluzione PING, forse verrà già detta nella sezione ULB

\chapter{Simulatore}
Questo capitolo descrive brevemente l'implementazione del simulatore
progettato per la valutazione degli algoritmi ULB e PS.

Il simulatore è di tipo a eventi discreti ed è costituito da tre
strati.

Il primo strato è denominato \emph{de-sim} e costituisce un
\emph{framework} generico che definisce le classi di base da estendere
per modellare gli oggetti e i collegamenti, implementa la gestione di
eventi ed errori, l'instaurazione di collegamenti tra oggetti e
definisce primitive di input e output per lo scambio di oggetti tra
attori collegati.

Il secondo strato è denominato \emph{ulb-sim} e si basa su de-sim
estendendone le classi e specializzandone i metodi, per modellare una
versione semplificata del meccanismo RWMA.

Il terzo strato è denominato \emph{ulb-snr} e descrive lo scenario da
simulare instanziando le classi definite in ulb-sim e inizializzando
gli oggetti e gli eventi di partenza.

In altre parole, de-sim definisce come i meccanismi della simulazione,
ulb-sim gli oggetti partecipanti e infine ulb-snr dispone i
partecipanti nello scenario che si vuole raffigurare.

L'architettura a strati serve a mantenere indipendenza tra ciò che
definisce il ``cosa'' (ulb-sim) e ciò che definisce il ``come''
(ulb-snr): per esempio è possibile costruire nuovi scenari basati su
ulb-sim senza modificarne il codice.

Questra struttura è simile a quella del simulatore ns-2, in cui gli
oggetti della simulazione sono definiti da una gerarchia di classi in
C++, mentre gli scenari vengono definiti attraverso script Tcl
\cite{bib:ns-2}.

I tre strati sono scritti in Common Lisp \cite{bib:clhs}.

È importante notare che, a questo stadio di sviluppo, il simulatore
non punta al realismo fisico della simulazione. Per esempio, nelle
comunicazioni wireless non venendo presi in considerazione parametri
fisici come la qualità del segnale radio in relazione alla distanza
del client dall'access point. Tutti i dettagli di una connessione
wireless sono astratti dietro ai parametri di banda, latenza e
probabilità di errore; in particolare la rilevazione dell'ultimo
parametro sarà fondamentale per determinare la scelta dell'interfaccia
migliore. In quest'ottica, per simulare un calo di qualità del segnale
wireless dovuto all'aumentare della distanza tra client e access point
è sufficiente decidere quanto questo evento incida sulla probabilità
d'errore del collegamento e modificarla di conseguenza.

\chapter{Valutazioni}
TODO: Metriche con cui valuto il mio sistema. Deduzioni su misurazioni
effettuate. Perché ho misurato certe cose e non altre.

TODO: qui non ho la più pallida idea di cosa scrivere.

\chapter*{Conclusioni}
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}
\addcontentsline{toc}{chapter}{Conclusioni}
TODO: che concludo?

\renewcommand{\chaptermark}[1]{\markright{\thechapter \ #1}{}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\appendix
\chapter{Codice de-sim}
\rhead[\fancyplain{}{\bfseries Appendice \thechapter: Codice de-sim}]{\fancyplain{}{\bfseries\thepage}}
prova

\chapter{Codice ulb-sim}
\rhead[\fancyplain{}{\bfseries Appendice \thechapter: Codice ulb-sim}]{\fancyplain{}{\bfseries\thepage}}
prova

\end{comment}

\begin{thebibliography}{90}
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
\addcontentsline{toc}{chapter}{Bibliografia}
\bibitem{bib:mipv6} RFC3775, ``Mobility Support in IPv6'',
  http://tools.ietf.org/html/rfc3775, giugno 2004
\bibitem{bib:mcoa} RFC5648, ``Multiple Care-of Addresses
  Registration'', http://tools.ietf.org/html/rfc5648, ottobre 2009
\bibitem{bib:hip} RFC5201 ``Host Identity Protocol'',
  http://tools.ietf.org/html/rfc5201, aprile 2008
\bibitem{bib:itu-t} ITU--T Recommendation G. 114, ``One--way
  Transmission'', maggio 2003
\bibitem{bib:abps} V. Ghini, G. Lodi, F. Panzieri, ``Always Best
  Packet Switching: the Mobile VoIP Case Study'', Achademy Plublisher,
  Journal of Communications, accepted for publication.
\bibitem{bib:abc} E. Gustafsson et al., ``Always Best Connected'',
  IEEE Comm. Mag., vol. 10, no. 1, Feb 2003, pp. 49--55.
\bibitem{bib:ns-2} http://nsnam.isi.edu/nsnam/, ottobre 2009
\bibitem{bib:clhs}
  http://www.lispworks.com/documentation/HyperSpec/Front/,
  ottobre 2009
\end{thebibliography}
\end{document}
